Here's a minimal Rust reproduction of the memory leak:

Cargo.toml:

[package]
name = "wgpu-memory-leak-repro"
version = "0.1.0"
edition = "2021"

[dependencies]
wgpu = "24.0"
pollster = "0.4"


src/main.rs:

use wgpu::*;

fn main() {
    pollster::block_on(run());
}

async fn run() {
    let instance = Instance::new(&InstanceDescriptor {
        backends: Backends::METAL,
        ..Default::default()
    });

    let adapter = instance
        .request_adapter(&RequestAdapterOptions::default())
        .await
        .expect("Failed to get adapter");

    let (device, queue) = adapter
        .request_device(&DeviceDescriptor::default(), None)
        .await
        .expect("Failed to get device");

    println!("Running memory leak reproduction...");
    println!("Watch memory usage in Activity Monitor or Instruments.");

    let shader_source = r#"
        @vertex
        fn vs_main(@builtin(vertex_index) idx: u32) -> @builtin(position) vec4<f32> {
            var positions = array<vec2<f32>, 3>(
                vec2<f32>(0.0, 0.5),
                vec2<f32>(-0.5, -0.5),
                vec2<f32>(0.5, -0.5)
            );
            return vec4<f32>(positions[idx], 0.0, 1.0);
        }

        @fragment
        fn fs_main() -> @location(0) vec4<f32> {
            return vec4<f32>(1.0, 0.0, 0.0, 1.0);
        }
    "#;

    loop {
        let shader = device.create_shader_module(ShaderModuleDescriptor {
            label: Some("leak_shader"),
            source: ShaderSource::Wgsl(shader_source.into()),
        });

        let pipeline_layout = device.create_pipeline_layout(&PipelineLayoutDescriptor {
            label: Some("leak_pipeline_layout"),
            bind_group_layouts: &[],
            push_constant_ranges: &[],
        });

        let _pipeline = device.create_render_pipeline(&RenderPipelineDescriptor {
            label: Some("leak_pipeline"),
            layout: Some(&pipeline_layout),
            vertex: VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[],
                compilation_options: Default::default(),
            },
            fragment: Some(FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(ColorTargetState {
                    format: TextureFormat::Bgra8Unorm,
                    blend: None,
                    write_mask: ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: PrimitiveState::default(),
            depth_stencil: None,
            multisample: MultisampleState::default(),
            multiview: None,
            cache: None,
        });

        std::thread::sleep(std::time::Duration::from_millis(10));
    }
}


To run:
1. cargo run --release
2. Watch memory in Activity Monitor or use Instruments

Expected behavior: Memory should stay stable
Actual behavior: Memory grows ~1MB every 10 seconds

The leak appears in Metal driver code at AGX::Compiler::compileProgram, suggesting this is a Metal/driver-level issue rather than wgpu.
