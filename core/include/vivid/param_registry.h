#pragma once

/**
 * @file param_registry.h
 * @brief Parameter registry for automatic introspection
 *
 * Provides ParamRef (type-erased parameter reference) and ParamRegistry
 * (mixin class) to reduce operator boilerplate. Instead of manually
 * implementing params(), getParam(), setParam() for each operator,
 * use registerParam() and let the base class handle introspection.
 *
 * @par Example
 * @code
 * class MyEffect : public TextureOperator {
 * public:
 *     MyEffect() {
 *         registerParam(m_intensity);
 *         registerParam(m_color);
 *     }
 *     // params(), getParam(), setParam() auto-generated by base class!
 *
 * private:
 *     Param<float> m_intensity{"intensity", 1.0f, 0.0f, 2.0f};
 *     ColorParam m_color{"color", 1.0f, 1.0f, 1.0f, 1.0f};
 * };
 * @endcode
 */

#include <vivid/param.h>
#include <vector>
#include <string>

namespace vivid {

/**
 * @brief Type-erased reference to a parameter
 *
 * Wraps any Param<T>, Vec2Param, Vec3Param, ColorParam, or FilePathParam
 * and provides uniform access for introspection.
 */
class ParamRef {
public:
    /// @brief Construct from Param<float>
    ParamRef(Param<float>* p) : m_ptr(p), m_type(ParamType::Float) {}

    /// @brief Construct from Param<int>
    ParamRef(Param<int>* p) : m_ptr(p), m_type(ParamType::Int) {}

    /// @brief Construct from Param<bool>
    ParamRef(Param<bool>* p) : m_ptr(p), m_type(ParamType::Bool) {}

    /// @brief Construct from Vec2Param
    ParamRef(Vec2Param* p) : m_ptr(p), m_type(ParamType::Vec2) {}

    /// @brief Construct from Vec3Param
    ParamRef(Vec3Param* p) : m_ptr(p), m_type(ParamType::Vec3) {}

    /// @brief Construct from ColorParam
    ParamRef(ColorParam* p) : m_ptr(p), m_type(ParamType::Color) {}

    /// @brief Construct from FilePathParam
    ParamRef(FilePathParam* p) : m_ptr(p), m_type(ParamType::FilePath) {}

    /// @brief Get parameter name
    const char* name() const {
        switch (m_type) {
            case ParamType::Float:    return static_cast<Param<float>*>(m_ptr)->name();
            case ParamType::Int:      return static_cast<Param<int>*>(m_ptr)->name();
            case ParamType::Bool:     return static_cast<Param<bool>*>(m_ptr)->name();
            case ParamType::Vec2:     return static_cast<Vec2Param*>(m_ptr)->name();
            case ParamType::Vec3:     return static_cast<Vec3Param*>(m_ptr)->name();
            case ParamType::Color:    return static_cast<ColorParam*>(m_ptr)->name();
            case ParamType::FilePath: return static_cast<FilePathParam*>(m_ptr)->name();
            default:                  return "";
        }
    }

    /// @brief Get parameter type
    ParamType type() const { return m_type; }

    /// @brief Generate ParamDecl for introspection
    ParamDecl decl() const {
        switch (m_type) {
            case ParamType::Float:    return static_cast<Param<float>*>(m_ptr)->decl();
            case ParamType::Int:      return static_cast<Param<int>*>(m_ptr)->decl();
            case ParamType::Bool:     return static_cast<Param<bool>*>(m_ptr)->decl();
            case ParamType::Vec2:     return static_cast<Vec2Param*>(m_ptr)->decl();
            case ParamType::Vec3:     return static_cast<Vec3Param*>(m_ptr)->decl();
            case ParamType::Color:    return static_cast<ColorParam*>(m_ptr)->decl();
            case ParamType::FilePath: return static_cast<FilePathParam*>(m_ptr)->decl();
            default:                  return {};
        }
    }

    /// @brief Get parameter value into float array
    bool get(float out[4]) const {
        switch (m_type) {
            case ParamType::Float: {
                auto* p = static_cast<Param<float>*>(m_ptr);
                out[0] = p->get();
                return true;
            }
            case ParamType::Int: {
                auto* p = static_cast<Param<int>*>(m_ptr);
                out[0] = static_cast<float>(p->get());
                return true;
            }
            case ParamType::Bool: {
                auto* p = static_cast<Param<bool>*>(m_ptr);
                out[0] = p->get() ? 1.0f : 0.0f;
                return true;
            }
            case ParamType::Vec2: {
                auto* p = static_cast<Vec2Param*>(m_ptr);
                out[0] = p->x();
                out[1] = p->y();
                return true;
            }
            case ParamType::Vec3: {
                auto* p = static_cast<Vec3Param*>(m_ptr);
                out[0] = p->x();
                out[1] = p->y();
                out[2] = p->z();
                return true;
            }
            case ParamType::Color: {
                auto* p = static_cast<ColorParam*>(m_ptr);
                out[0] = p->r();
                out[1] = p->g();
                out[2] = p->b();
                out[3] = p->a();
                return true;
            }
            case ParamType::FilePath:
                // FilePath doesn't use float array
                return false;
            default:
                return false;
        }
    }

    /// @brief Set parameter value from float array
    /// @return True if value was set (and changed)
    bool set(const float value[4]) {
        switch (m_type) {
            case ParamType::Float: {
                auto* p = static_cast<Param<float>*>(m_ptr);
                if (p->get() != value[0]) {
                    *p = value[0];
                    return true;
                }
                return false;
            }
            case ParamType::Int: {
                auto* p = static_cast<Param<int>*>(m_ptr);
                int newVal = static_cast<int>(value[0]);
                if (p->get() != newVal) {
                    *p = newVal;
                    return true;
                }
                return false;
            }
            case ParamType::Bool: {
                auto* p = static_cast<Param<bool>*>(m_ptr);
                bool newVal = value[0] > 0.5f;
                if (p->get() != newVal) {
                    *p = newVal;
                    return true;
                }
                return false;
            }
            case ParamType::Vec2: {
                auto* p = static_cast<Vec2Param*>(m_ptr);
                if (p->x() != value[0] || p->y() != value[1]) {
                    p->set(value[0], value[1]);
                    return true;
                }
                return false;
            }
            case ParamType::Vec3: {
                auto* p = static_cast<Vec3Param*>(m_ptr);
                if (p->x() != value[0] || p->y() != value[1] || p->z() != value[2]) {
                    p->set(value[0], value[1], value[2]);
                    return true;
                }
                return false;
            }
            case ParamType::Color: {
                auto* p = static_cast<ColorParam*>(m_ptr);
                if (p->r() != value[0] || p->g() != value[1] || p->b() != value[2] || p->a() != value[3]) {
                    p->set(value[0], value[1], value[2], value[3]);
                    return true;
                }
                return false;
            }
            case ParamType::FilePath:
                // FilePath doesn't use float array
                return false;
            default:
                return false;
        }
    }

private:
    void* m_ptr;
    ParamType m_type;
};

/**
 * @brief Mixin class providing automatic parameter introspection
 *
 * Inherit from this class and call registerParam() for each parameter
 * in your constructor. The registeredParams(), getRegisteredParam(),
 * and setRegisteredParam() methods provide automatic implementations
 * that can be used by derived operator classes.
 */
class ParamRegistry {
public:
    /// @brief Register a parameter for introspection
    template<typename T>
    void registerParam(T& param) {
        m_params.push_back(ParamRef(&param));
    }

    /// @brief Get all registered parameters as ParamDecl vector
    std::vector<ParamDecl> registeredParams() const {
        std::vector<ParamDecl> result;
        result.reserve(m_params.size());
        for (const auto& p : m_params) {
            result.push_back(p.decl());
        }
        return result;
    }

    /// @brief Get a registered parameter value by name
    bool getRegisteredParam(const std::string& name, float out[4]) const {
        for (const auto& p : m_params) {
            if (name == p.name()) {
                return p.get(out);
            }
        }
        return false;
    }

    /// @brief Set a registered parameter value by name
    /// @return True if parameter was found and value changed
    bool setRegisteredParam(const std::string& name, const float value[4]) {
        for (auto& p : m_params) {
            if (name == p.name()) {
                return p.set(value);
            }
        }
        return false;
    }

protected:
    std::vector<ParamRef> m_params;
};

} // namespace vivid
