/**
 * @file video_audio.cpp
 * @brief VideoAudio operator implementation
 */

#include <vivid/video/video_audio.h>
#include <vivid/video/video_player.h>
#include <vivid/context.h>
#include <vivid/chain.h>
#include <iostream>

namespace vivid::video {

VideoAudio::VideoAudio() = default;

void VideoAudio::setSource(const std::string& videoOpName) {
    m_sourceName = videoOpName;
}

void VideoAudio::init(Context& ctx) {
    // Resolve source VideoPlayer by name
    if (m_sourceName.empty()) {
        std::cerr << "[VideoAudio] No source specified\n";
        return;
    }

    Operator* op = ctx.chain().getByName(m_sourceName);
    if (!op) {
        std::cerr << "[VideoAudio] Source '" << m_sourceName << "' not found\n";
        return;
    }

    // Check if it's a VideoPlayer
    m_videoPlayer = dynamic_cast<VideoPlayer*>(op);
    if (!m_videoPlayer) {
        std::cerr << "[VideoAudio] Source '" << m_sourceName << "' is not a VideoPlayer\n";
        return;
    }

    m_connectedToSource = true;

    // Allocate output buffer with default settings
    // (will be adjusted when we know the actual audio format)
    allocateOutput(AUDIO_BLOCK_SIZE, AUDIO_CHANNELS, AUDIO_SAMPLE_RATE);

    std::cout << "[VideoAudio] Connected to '" << m_sourceName << "'" << std::endl;
}

void VideoAudio::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() only handles setup tasks on the main thread.
    if (!m_connectedToSource || !m_videoPlayer) {
        return;
    }

    // On first frame with audio, disable internal playback to avoid double audio
    if (m_videoPlayer->hasAudio() && m_videoPlayer->isInternalAudioEnabled()) {
        m_videoPlayer->setInternalAudioEnabled(false);
        std::cout << "[VideoAudio] Disabled internal audio on '" << m_sourceName << "'" << std::endl;
    }
}

void VideoAudio::generateBlock(uint32_t frameCount) {
    if (!m_connectedToSource || !m_videoPlayer) {
        // Clear output buffer
        if (m_output.frameCount != frameCount) {
            m_output.resize(frameCount);
        }
        clearOutput();
        return;
    }

    // Check if video has audio
    if (!m_videoPlayer->hasAudio()) {
        if (m_output.frameCount != frameCount) {
            m_output.resize(frameCount);
        }
        clearOutput();
        return;
    }

    // Ensure output buffer is large enough
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    // Read audio samples from video player's audio buffer
    // The audio buffer in HAPDecoder/AVFDecoder is thread-safe for reading
    uint32_t framesRead = m_videoPlayer->readAudioSamples(
        m_output.samples, frameCount);

    // Zero any remaining samples if we didn't get enough
    if (framesRead < frameCount) {
        uint32_t offset = framesRead * AUDIO_CHANNELS;
        uint32_t count = (frameCount - framesRead) * AUDIO_CHANNELS;
        for (uint32_t i = 0; i < count; ++i) {
            m_output.samples[offset + i] = 0.0f;
        }
    }
}

void VideoAudio::cleanup() {
    // Re-enable internal audio in VideoPlayer if we disabled it
    if (m_connectedToSource && m_videoPlayer) {
        m_videoPlayer->setInternalAudioEnabled(true);
    }

    m_videoPlayer = nullptr;
    m_connectedToSource = false;
    releaseOutput();
}

} // namespace vivid::video
