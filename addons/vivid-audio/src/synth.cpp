#include <vivid/audio/synth.h>
#include <vivid/audio_graph.h>
#include <vivid/context.h>
#include <cmath>

namespace vivid::audio {

void Synth::init(Context& ctx) {
    m_sampleRate = AUDIO_SAMPLE_RATE;
    allocateOutput();
    reset();
    m_initialized = true;
}

void Synth::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() is only called on the main thread for visual updates.
    // Legacy mode: if not using AudioGraph, generate here
    if (!m_initialized) return;
}

void Synth::generateBlock(uint32_t frameCount) {
    if (!m_initialized) return;

    // Resize buffer if needed
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    // Calculate effective frequency with detune
    float baseFreq = static_cast<float>(frequency);
    float detuneRatio = centsToRatio(static_cast<float>(detune));
    float freq = baseFreq * detuneRatio;

    // Phase increment per sample
    float phaseInc = freq / static_cast<float>(m_sampleRate);

    float vol = static_cast<float>(volume);

    for (uint32_t i = 0; i < frameCount; ++i) {
        // Compute envelope
        float env = computeEnvelope();

        // Generate sample with envelope
        float sample = generateSample(m_phase) * vol * env;

        // Write stereo
        m_output.samples[i * 2] = sample;
        m_output.samples[i * 2 + 1] = sample;

        // Advance phase (wrap at 1.0)
        m_phase += phaseInc;
        if (m_phase >= 1.0f) m_phase -= 1.0f;

        // Advance envelope
        advanceEnvelope(1);
    }
}

void Synth::handleEvent(const AudioEvent& event) {
    switch (event.type) {
        case AudioEventType::NoteOn:
            if (event.value1 > 0.0f) {
                frequency = event.value1;  // frequency in Hz
            }
            noteOnInternal();
            break;
        case AudioEventType::NoteOff:
            noteOffInternal();
            break;
        case AudioEventType::Trigger:
            noteOnInternal();
            break;
        case AudioEventType::Reset:
            reset();
            break;
        default:
            break;
    }
}

void Synth::cleanup() {
    releaseOutput();
    m_initialized = false;
}

void Synth::noteOn() {
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueNoteOn(m_operatorId, static_cast<float>(frequency));
    } else {
        noteOnInternal();
    }
}

void Synth::noteOn(float hz) {
    frequency = hz;  // Set frequency first (will be read in handleEvent)
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueNoteOn(m_operatorId, hz);
    } else {
        noteOnInternal();
    }
}

void Synth::noteOnInternal() {
    m_envStage = EnvelopeStage::Attack;
    m_envProgress = 0.0f;
}

void Synth::noteOff() {
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueNoteOff(m_operatorId);
    } else {
        noteOffInternal();
    }
}

void Synth::noteOffInternal() {
    if (m_envStage != EnvelopeStage::Idle && m_envStage != EnvelopeStage::Release) {
        m_releaseStartValue = m_envValue;
        m_envStage = EnvelopeStage::Release;
        m_envProgress = 0.0f;
    }
}

void Synth::reset() {
    m_phase = 0.0f;
    m_envStage = EnvelopeStage::Idle;
    m_envValue = 0.0f;
    m_envProgress = 0.0f;
    m_releaseStartValue = 0.0f;
}

float Synth::generateSample(float phase) const {
    switch (m_waveform) {
        case Waveform::Sine:
            return std::sin(phase * TWO_PI);

        case Waveform::Triangle:
            if (phase < 0.5f) {
                return 4.0f * phase - 1.0f;
            } else {
                return 3.0f - 4.0f * phase;
            }

        case Waveform::Square:
            return (phase < 0.5f) ? 1.0f : -1.0f;

        case Waveform::Saw:
            return 2.0f * phase - 1.0f;

        case Waveform::Pulse:
            return (phase < static_cast<float>(pulseWidth)) ? 1.0f : -1.0f;

        default:
            return 0.0f;
    }
}

float Synth::centsToRatio(float cents) const {
    return std::pow(2.0f, cents / 1200.0f);
}

float Synth::computeEnvelope() {
    switch (m_envStage) {
        case EnvelopeStage::Idle:
            return 0.0f;

        case EnvelopeStage::Attack:
            return m_envValue + (1.0f - m_envValue) * m_envProgress;

        case EnvelopeStage::Decay: {
            float sustainLevel = static_cast<float>(sustain);
            return 1.0f + (sustainLevel - 1.0f) * m_envProgress;
        }

        case EnvelopeStage::Sustain:
            return static_cast<float>(sustain);

        case EnvelopeStage::Release:
            return m_releaseStartValue * (1.0f - m_envProgress);

        default:
            return 0.0f;
    }
}

void Synth::advanceEnvelope(uint32_t samples) {
    if (m_envStage == EnvelopeStage::Idle || m_envStage == EnvelopeStage::Sustain) {
        m_envValue = computeEnvelope();
        return;
    }

    // Get stage duration in samples
    float stageDuration = 0.0f;
    switch (m_envStage) {
        case EnvelopeStage::Attack:
            stageDuration = static_cast<float>(attack) * m_sampleRate;
            break;
        case EnvelopeStage::Decay:
            stageDuration = static_cast<float>(decay) * m_sampleRate;
            break;
        case EnvelopeStage::Release:
            stageDuration = static_cast<float>(release) * m_sampleRate;
            break;
        default:
            break;
    }

    // Advance progress
    if (stageDuration > 0.0f) {
        m_envProgress += static_cast<float>(samples) / stageDuration;
    }

    // Update current value
    m_envValue = computeEnvelope();

    // Check for stage transitions
    if (m_envProgress >= 1.0f) {
        switch (m_envStage) {
            case EnvelopeStage::Attack:
                m_envStage = EnvelopeStage::Decay;
                m_envProgress = 0.0f;
                m_envValue = 1.0f;
                break;

            case EnvelopeStage::Decay:
                m_envStage = EnvelopeStage::Sustain;
                m_envProgress = 0.0f;
                m_envValue = static_cast<float>(sustain);
                break;

            case EnvelopeStage::Release:
                m_envStage = EnvelopeStage::Idle;
                m_envProgress = 0.0f;
                m_envValue = 0.0f;
                break;

            default:
                break;
        }
    }
}

} // namespace vivid::audio
