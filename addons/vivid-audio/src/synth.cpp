#include <vivid/audio/synth.h>
#include <vivid/audio_graph.h>
#include <vivid/context.h>
#include <imgui.h>
#include <cmath>

namespace vivid::audio {

void Synth::init(Context& ctx) {
    m_sampleRate = AUDIO_SAMPLE_RATE;
    allocateOutput();
    reset();
    m_initialized = true;
}

void Synth::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() is only called on the main thread for visual updates.
    // Legacy mode: if not using AudioGraph, generate here
    if (!m_initialized) return;
}

void Synth::generateBlock(uint32_t frameCount) {
    if (!m_initialized) return;

    // Resize buffer if needed
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    // Calculate effective frequency with detune
    float baseFreq = static_cast<float>(frequency);
    float detuneRatio = centsToRatio(static_cast<float>(detune));
    float freq = baseFreq * detuneRatio;

    // Phase increment per sample
    float phaseInc = freq / static_cast<float>(m_sampleRate);

    float vol = static_cast<float>(volume);

    for (uint32_t i = 0; i < frameCount; ++i) {
        // Compute envelope
        float env = computeEnvelope();

        // Generate sample with envelope
        float sample = generateSample(m_phase) * vol * env;

        // Write stereo
        m_output.samples[i * 2] = sample;
        m_output.samples[i * 2 + 1] = sample;

        // Advance phase (wrap at 1.0)
        m_phase += phaseInc;
        if (m_phase >= 1.0f) m_phase -= 1.0f;

        // Advance envelope
        advanceEnvelope(1);
    }
}

void Synth::handleEvent(const AudioEvent& event) {
    switch (event.type) {
        case AudioEventType::NoteOn:
            if (event.value1 > 0.0f) {
                frequency = event.value1;  // frequency in Hz
            }
            noteOnInternal();
            break;
        case AudioEventType::NoteOff:
            noteOffInternal();
            break;
        case AudioEventType::Trigger:
            noteOnInternal();
            break;
        case AudioEventType::Reset:
            reset();
            break;
        default:
            break;
    }
}

void Synth::cleanup() {
    releaseOutput();
    m_initialized = false;
}

void Synth::noteOn() {
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueNoteOn(m_operatorId, static_cast<float>(frequency));
    } else {
        noteOnInternal();
    }
}

void Synth::noteOn(float hz) {
    frequency = hz;  // Set frequency first (will be read in handleEvent)
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueNoteOn(m_operatorId, hz);
    } else {
        noteOnInternal();
    }
}

void Synth::noteOnInternal() {
    m_envStage = EnvelopeStage::Attack;
    m_envProgress = 0.0f;
}

void Synth::noteOff() {
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueNoteOff(m_operatorId);
    } else {
        noteOffInternal();
    }
}

void Synth::noteOffInternal() {
    if (m_envStage != EnvelopeStage::Idle && m_envStage != EnvelopeStage::Release) {
        m_releaseStartValue = m_envValue;
        m_envStage = EnvelopeStage::Release;
        m_envProgress = 0.0f;
    }
}

void Synth::reset() {
    m_phase = 0.0f;
    m_envStage = EnvelopeStage::Idle;
    m_envValue = 0.0f;
    m_envProgress = 0.0f;
    m_releaseStartValue = 0.0f;
}

float Synth::generateSample(float phase) const {
    switch (m_waveform) {
        case Waveform::Sine:
            return std::sin(phase * TWO_PI);

        case Waveform::Triangle:
            if (phase < 0.5f) {
                return 4.0f * phase - 1.0f;
            } else {
                return 3.0f - 4.0f * phase;
            }

        case Waveform::Square:
            return (phase < 0.5f) ? 1.0f : -1.0f;

        case Waveform::Saw:
            return 2.0f * phase - 1.0f;

        case Waveform::Pulse:
            return (phase < static_cast<float>(pulseWidth)) ? 1.0f : -1.0f;

        default:
            return 0.0f;
    }
}

float Synth::centsToRatio(float cents) const {
    return std::pow(2.0f, cents / 1200.0f);
}

float Synth::computeEnvelope() {
    switch (m_envStage) {
        case EnvelopeStage::Idle:
            return 0.0f;

        case EnvelopeStage::Attack:
            return m_envValue + (1.0f - m_envValue) * m_envProgress;

        case EnvelopeStage::Decay: {
            float sustainLevel = static_cast<float>(sustain);
            return 1.0f + (sustainLevel - 1.0f) * m_envProgress;
        }

        case EnvelopeStage::Sustain:
            return static_cast<float>(sustain);

        case EnvelopeStage::Release:
            return m_releaseStartValue * (1.0f - m_envProgress);

        default:
            return 0.0f;
    }
}

void Synth::advanceEnvelope(uint32_t samples) {
    if (m_envStage == EnvelopeStage::Idle || m_envStage == EnvelopeStage::Sustain) {
        m_envValue = computeEnvelope();
        return;
    }

    // Get stage duration in samples
    float stageDuration = 0.0f;
    switch (m_envStage) {
        case EnvelopeStage::Attack:
            stageDuration = static_cast<float>(attack) * m_sampleRate;
            break;
        case EnvelopeStage::Decay:
            stageDuration = static_cast<float>(decay) * m_sampleRate;
            break;
        case EnvelopeStage::Release:
            stageDuration = static_cast<float>(release) * m_sampleRate;
            break;
        default:
            break;
    }

    // Advance progress
    if (stageDuration > 0.0f) {
        m_envProgress += static_cast<float>(samples) / stageDuration;
    }

    // Update current value
    m_envValue = computeEnvelope();

    // Check for stage transitions
    if (m_envProgress >= 1.0f) {
        switch (m_envStage) {
            case EnvelopeStage::Attack:
                m_envStage = EnvelopeStage::Decay;
                m_envProgress = 0.0f;
                m_envValue = 1.0f;
                break;

            case EnvelopeStage::Decay:
                m_envStage = EnvelopeStage::Sustain;
                m_envProgress = 0.0f;
                m_envValue = static_cast<float>(sustain);
                break;

            case EnvelopeStage::Release:
                m_envStage = EnvelopeStage::Idle;
                m_envProgress = 0.0f;
                m_envValue = 0.0f;
                break;

            default:
                break;
        }
    }
}

bool Synth::drawVisualization(ImDrawList* dl, float minX, float minY, float maxX, float maxY) {
    ImVec2 min(minX, minY);
    ImVec2 max(maxX, maxY);
    float width = maxX - minX;
    float height = maxY - minY;
    float cx = (minX + maxX) * 0.5f;
    float cy = (minY + maxY) * 0.5f;

    // Dark blue background
    dl->AddRectFilled(min, max, IM_COL32(25, 35, 55, 255), 4.0f);

    float env = m_envValue;

    // Draw waveform icon in top-left
    float iconSize = std::min(width, height) * 0.35f;
    float iconX = min.x + 6;
    float iconY = min.y + 6;
    ImU32 waveColor = IM_COL32(100, 180, 255, 200);

    // Draw mini waveform based on type
    if (m_waveform == Waveform::Sine) {
        for (int i = 0; i < 16; i++) {
            float t1 = i / 16.0f;
            float t2 = (i + 1) / 16.0f;
            float y1 = iconY + iconSize * 0.5f - std::sin(t1 * TWO_PI) * iconSize * 0.4f;
            float y2 = iconY + iconSize * 0.5f - std::sin(t2 * TWO_PI) * iconSize * 0.4f;
            dl->AddLine(ImVec2(iconX + t1 * iconSize, y1),
                       ImVec2(iconX + t2 * iconSize, y2), waveColor, 1.5f);
        }
    } else if (m_waveform == Waveform::Square || m_waveform == Waveform::Pulse) {
        float midY = iconY + iconSize * 0.5f;
        float amp = iconSize * 0.35f;
        dl->AddLine(ImVec2(iconX, midY - amp), ImVec2(iconX + iconSize * 0.5f, midY - amp), waveColor, 1.5f);
        dl->AddLine(ImVec2(iconX + iconSize * 0.5f, midY - amp), ImVec2(iconX + iconSize * 0.5f, midY + amp), waveColor, 1.5f);
        dl->AddLine(ImVec2(iconX + iconSize * 0.5f, midY + amp), ImVec2(iconX + iconSize, midY + amp), waveColor, 1.5f);
    } else if (m_waveform == Waveform::Saw) {
        float midY = iconY + iconSize * 0.5f;
        float amp = iconSize * 0.35f;
        dl->AddLine(ImVec2(iconX, midY + amp), ImVec2(iconX + iconSize * 0.5f, midY - amp), waveColor, 1.5f);
        dl->AddLine(ImVec2(iconX + iconSize * 0.5f, midY - amp), ImVec2(iconX + iconSize * 0.5f, midY + amp), waveColor, 1.5f);
        dl->AddLine(ImVec2(iconX + iconSize * 0.5f, midY + amp), ImVec2(iconX + iconSize, midY - amp), waveColor, 1.5f);
    } else if (m_waveform == Waveform::Triangle) {
        float midY = iconY + iconSize * 0.5f;
        float amp = iconSize * 0.35f;
        dl->AddLine(ImVec2(iconX, midY), ImVec2(iconX + iconSize * 0.25f, midY - amp), waveColor, 1.5f);
        dl->AddLine(ImVec2(iconX + iconSize * 0.25f, midY - amp), ImVec2(iconX + iconSize * 0.75f, midY + amp), waveColor, 1.5f);
        dl->AddLine(ImVec2(iconX + iconSize * 0.75f, midY + amp), ImVec2(iconX + iconSize, midY), waveColor, 1.5f);
    }

    // Draw ADSR envelope visualization (right side)
    float envWidth = width * 0.55f;
    float envHeight = height * 0.6f;
    float envX = max.x - envWidth - 6;
    float envY = cy - envHeight * 0.5f;

    // ADSR shape (static representation)
    ImU32 adsrColor = IM_COL32(80, 120, 180, 150);
    float a = static_cast<float>(attack);
    float d = static_cast<float>(decay);
    float s = static_cast<float>(sustain);
    float r = static_cast<float>(release);
    float total = a + d + r + 0.2f;  // Add sustain hold time
    float scaleX = envWidth / total;

    float ax = envX + a * scaleX;
    float dx = ax + d * scaleX;
    float sx = dx + 0.2f * scaleX;  // Sustain hold
    float rx = sx + r * scaleX;

    // Draw ADSR path
    dl->AddLine(ImVec2(envX, envY + envHeight), ImVec2(ax, envY), adsrColor, 1.0f);  // Attack
    dl->AddLine(ImVec2(ax, envY), ImVec2(dx, envY + envHeight * (1 - s)), adsrColor, 1.0f);  // Decay
    dl->AddLine(ImVec2(dx, envY + envHeight * (1 - s)), ImVec2(sx, envY + envHeight * (1 - s)), adsrColor, 1.0f);  // Sustain
    dl->AddLine(ImVec2(sx, envY + envHeight * (1 - s)), ImVec2(rx, envY + envHeight), adsrColor, 1.0f);  // Release

    // Current envelope level bar
    float barW = 8.0f;
    float barH = envHeight * env;
    ImU32 levelColor = IM_COL32(100 + (int)(155 * env), 180, 255, 255);
    dl->AddRectFilled(
        ImVec2(max.x - barW - 4, envY + envHeight - barH),
        ImVec2(max.x - 4, envY + envHeight),
        levelColor, 2.0f);

    return true;
}

} // namespace vivid::audio
