#include <vivid/audio/hihat.h>
#include <vivid/audio_graph.h>
#include <vivid/context.h>
#include <cmath>

namespace vivid::audio {

void HiHat::init(Context& ctx) {
    m_sampleRate = AUDIO_SAMPLE_RATE;
    allocateOutput();
    reset();
    m_initialized = true;
}

void HiHat::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() is only called on the main thread for visual updates.
    if (!m_initialized) return;
}

void HiHat::generateBlock(uint32_t frameCount) {
    if (!m_initialized) return;

    // Resize buffer if needed
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    float decayTime = static_cast<float>(decay) * m_sampleRate;
    float toneAmt = static_cast<float>(tone);
    float ringAmt = static_cast<float>(ring);
    float vol = static_cast<float>(volume);

    float decayRate = (decayTime > 0) ? (1.0f / decayTime) : 1.0f;

    // Ring oscillator frequencies (metallic hi-hat character)
    // Based on 808 hi-hat - 6 square wave oscillators
    const float ringFreqs[6] = {205.3f, 304.4f, 369.6f, 522.7f, 540.0f, 800.0f};

    for (uint32_t i = 0; i < frameCount; ++i) {
        // Generate noise base
        float noise = generateNoise();

        // Add metallic ring (sum of square waves at inharmonic frequencies)
        float ring = 0.0f;
        if (ringAmt > 0.0f) {
            for (int r = 0; r < 6; ++r) {
                float phaseInc = ringFreqs[r] / m_sampleRate;
                ring += (m_ringPhase[r] < 0.5f) ? 1.0f : -1.0f;
                m_ringPhase[r] += phaseInc;
                if (m_ringPhase[r] >= 1.0f) m_ringPhase[r] -= 1.0f;
            }
            ring /= 6.0f;
        }

        // Mix noise and ring
        float sample = noise * (1.0f - ringAmt * 0.5f) + ring * ringAmt;

        // Apply highpass filter for brightness
        sample = highpass(sample, 0);

        // Additional bandpass for tone shaping
        float cutoff = 4000.0f + toneAmt * 8000.0f;  // 4kHz to 12kHz
        sample = bandpass(sample, 0);

        // Apply envelope
        sample *= m_env * vol;

        // Output
        m_output.samples[i * 2] = sample;
        m_output.samples[i * 2 + 1] = sample;

        // Decay envelope (exponential)
        m_env *= (1.0f - decayRate * 0.3f);
    }
}

void HiHat::handleEvent(const AudioEvent& event) {
    switch (event.type) {
        case AudioEventType::Trigger:
            triggerInternal();
            break;
        case AudioEventType::NoteOff:
            choke();
            break;
        case AudioEventType::Reset:
            reset();
            break;
        default:
            break;
    }
}

void HiHat::cleanup() {
    releaseOutput();
    m_initialized = false;
}

void HiHat::trigger() {
    if (m_audioGraph && m_operatorId != UINT32_MAX) {
        m_audioGraph->queueTrigger(m_operatorId);
    } else {
        triggerInternal();
    }
}

void HiHat::triggerInternal() {
    m_env = 1.0f;
}

void HiHat::choke() {
    m_env = 0.0f;
}

void HiHat::reset() {
    m_env = 0.0f;
    for (int i = 0; i < 6; ++i) m_ringPhase[i] = 0.0f;
    m_bpState1[0] = m_bpState1[1] = 0.0f;
    m_bpState2[0] = m_bpState2[1] = 0.0f;
    m_hpState[0] = m_hpState[1] = 0.0f;
}

float HiHat::generateNoise() {
    m_seed ^= m_seed << 13;
    m_seed ^= m_seed >> 17;
    m_seed ^= m_seed << 5;
    return (static_cast<float>(m_seed) / 2147483648.0f) - 1.0f;
}

float HiHat::bandpass(float in, int ch) {
    // Simple 2-pole bandpass around 8kHz
    float freq = 8000.0f;
    float Q = 2.0f;
    float omega = TWO_PI * freq / m_sampleRate;
    float f = 2.0f * std::sin(omega * 0.5f);  // Proper SVF frequency coefficient

    // State-variable filter (damping = 1/Q)
    float damp = 1.0f / Q;
    m_bpState2[ch] += f * m_bpState1[ch];  // lowpass
    float hp = in - m_bpState2[ch] - damp * m_bpState1[ch];
    m_bpState1[ch] += f * hp;  // bandpass

    return m_bpState1[ch];
}

float HiHat::highpass(float in, int ch) {
    // One-pole highpass at ~7kHz
    float alpha = 0.7f;  // Approximate for high cutoff
    float out = alpha * (m_hpState[ch] + in);
    float delta = in - m_hpState[ch];
    m_hpState[ch] = in;
    return out * 0.5f + delta * 0.5f;
}

} // namespace vivid::audio
