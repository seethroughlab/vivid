#include <vivid/audio/snare.h>
#include <vivid/audio_graph.h>
#include <vivid/context.h>
#include <vivid/viz_helpers.h>

#include <cmath>

namespace vivid::audio {

void Snare::init(Context& ctx) {
    m_sampleRate = AUDIO_SAMPLE_RATE;
    allocateOutput();
    reset();
    m_initialized = true;
}

void Snare::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    if (!m_initialized) return;
}

void Snare::generateBlock(uint32_t frameCount) {
    if (!m_initialized) return;

    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    float toneAmt = static_cast<float>(tone);
    float noiseAmt = static_cast<float>(noise);
    float freq = static_cast<float>(pitch);
    float toneDecayTime = static_cast<float>(toneDecay) * m_sampleRate;
    float noiseDecayTime = static_cast<float>(noiseDecay) * m_sampleRate;
    float snappyAmt = static_cast<float>(snappy);
    float vol = static_cast<float>(volume);

    float toneDecayRate = (toneDecayTime > 0) ? (1.0f / toneDecayTime) : 1.0f;
    float noiseDecayRate = (noiseDecayTime > 0) ? (1.0f / noiseDecayTime) : 1.0f;
    float phaseInc = freq / m_sampleRate;

    for (uint32_t i = 0; i < frameCount; ++i) {
        // Tone component (sine with slight 2nd harmonic)
        float tone = std::sin(m_phase * TWO_PI);
        tone += 0.3f * std::sin(m_phase * TWO_PI * 2.0f);  // 2nd harmonic
        tone *= m_toneEnv * toneAmt;

        // Noise component
        float noise = generateNoise();

        // Apply snappy highpass filter to noise
        if (snappyAmt > 0.0f) {
            float filtered = highpass(noise, 0);
            noise = noise * (1.0f - snappyAmt) + filtered * snappyAmt;
        }
        noise *= m_noiseEnv * noiseAmt;

        // Mix
        float sample = (tone + noise) * vol;

        // Output
        m_output.samples[i * 2] = sample;
        m_output.samples[i * 2 + 1] = sample;

        // Advance phase
        m_phase += phaseInc;
        if (m_phase >= 1.0f) m_phase -= 1.0f;

        // Decay envelopes (exponential)
        m_toneEnv *= (1.0f - toneDecayRate);
        m_noiseEnv *= (1.0f - noiseDecayRate * 0.5f);
    }
}

void Snare::handleEvent(const AudioEvent& event) {
    // Let base class handle Trigger -> onTrigger()
    AudioOperator::handleEvent(event);

    // Handle additional event types
    if (event.type == AudioEventType::Reset) {
        reset();
    }
}

void Snare::cleanup() {
    releaseOutput();
    m_initialized = false;
}

void Snare::onTrigger() {
    m_toneEnv = 1.0f;
    m_noiseEnv = 1.0f;
}

void Snare::reset() {
    m_phase = 0.0f;
    m_toneEnv = 0.0f;
    m_noiseEnv = 0.0f;
    m_hpState[0] = m_hpState[1] = 0.0f;
}

float Snare::generateNoise() {
    m_seed ^= m_seed << 13;
    m_seed ^= m_seed >> 17;
    m_seed ^= m_seed << 5;
    return (static_cast<float>(m_seed) / 2147483648.0f) - 1.0f;
}

float Snare::highpass(float in, int ch) {
    // Simple one-pole highpass at ~2kHz
    float cutoff = 2000.0f / m_sampleRate;
    float rc = 1.0f / (TWO_PI * cutoff);
    float alpha = rc / (rc + 1.0f / m_sampleRate);

    float out = alpha * (m_hpState[ch] + in - m_hpState[ch]);
    m_hpState[ch] = in;
    return out;
}

bool Snare::drawVisualization(VizDrawList* dl, float minX, float minY, float maxX, float maxY) {
    VizHelpers viz(dl);
    VizBounds bounds{minX, minY, maxX - minX, maxY - minY};

    viz.drawBackground(bounds);
    viz.drawDualEnvelope(bounds.inset(4), m_toneEnv, m_noiseEnv,
                         VizColors::EnvelopeWarm, VizColors::TextPrimary);
    return true;
}

} // namespace vivid::audio
