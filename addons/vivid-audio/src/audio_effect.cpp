#include <vivid/audio/audio_effect.h>
#include <vivid/chain.h>
#include <vivid/context.h>
#include <algorithm>
#include <iostream>
#include <cmath>

namespace vivid::audio {

void AudioEffect::init(Context& ctx) {
    // Allocate output buffer
    allocateOutput();

    // Find and connect to input operator
    if (!m_inputName.empty()) {
        Operator* op = ctx.chain().getByName(m_inputName);
        if (op && op->outputKind() == OutputKind::Audio) {
            m_connectedInput = static_cast<AudioOperator*>(op);
            setInput(0, op);  // Also set base class input for dependency tracking
        } else if (op) {
            std::cerr << "[" << name() << "] Input '" << m_inputName
                      << "' is not an audio operator" << std::endl;
        } else {
            std::cerr << "[" << name() << "] Input '" << m_inputName
                      << "' not found" << std::endl;
        }
    }

    // Initialize effect-specific state
    initEffect(ctx);
}

void AudioEffect::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() only handles runtime reconnection on the main thread.
    if (!m_inputName.empty()) {
        Operator* op = ctx.chain().getByName(m_inputName);
        if (op && op->outputKind() == OutputKind::Audio) {
            AudioOperator* audioOp = static_cast<AudioOperator*>(op);
            if (audioOp != m_connectedInput) {
                m_connectedInput = audioOp;
                setInput(0, op);  // Update dependency tracking
            }
        }
    }
}

void AudioEffect::generateBlock(uint32_t frameCount) {
    // Get input buffer - input operator's generateBlock has already been called
    const AudioBuffer* inputBuf = nullptr;
    if (m_connectedInput) {
        inputBuf = m_connectedInput->outputBuffer();
    }

    // Ensure output buffer is sized correctly
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    // No input: output silence
    if (!inputBuf || !inputBuf->isValid()) {
        clearOutput();
        return;
    }

    uint32_t frames = std::min(frameCount, inputBuf->frameCount);
    uint32_t channels = inputBuf->channels;

    // Sync bypass state from base class (UI uses setBypassed directly)
    m_bypass = Operator::isBypassed();

    // Bypass: copy input to output directly
    if (m_bypass) {
        uint32_t samplesToCopy = frames * channels;
        std::copy(inputBuf->samples,
                  inputBuf->samples + samplesToCopy,
                  m_output.samples);
        return;
    }

    // Process the effect
    if (m_mix >= 1.0f) {
        // Fully wet: process directly to output
        processEffect(inputBuf->samples, m_output.samples, frames);
    } else if (m_mix <= 0.0f) {
        // Fully dry: copy input to output
        uint32_t samplesToCopy = frames * channels;
        std::copy(inputBuf->samples,
                  inputBuf->samples + samplesToCopy,
                  m_output.samples);
    } else {
        // Mix: process to output, then blend with input
        processEffect(inputBuf->samples, m_output.samples, frames);

        // Blend: output = dry * (1 - mix) + wet * mix
        float dry = 1.0f - m_mix;
        float wet = m_mix;
        uint32_t totalSamples = frames * channels;
        for (uint32_t i = 0; i < totalSamples; ++i) {
            m_output.samples[i] = inputBuf->samples[i] * dry +
                                   m_output.samples[i] * wet;
        }
    }
}

void AudioEffect::cleanup() {
    cleanupEffect();
    releaseOutput();
    m_connectedInput = nullptr;
}

} // namespace vivid::audio
