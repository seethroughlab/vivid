#include <vivid/audio/kick.h>
#include <vivid/audio_graph.h>
#include <vivid/context.h>
#include <vivid/viz_helpers.h>

#include <cmath>

namespace vivid::audio {

void Kick::init(Context& ctx) {
    m_sampleRate = AUDIO_SAMPLE_RATE;
    allocateOutput();
    reset();
    m_initialized = true;
}

void Kick::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() is only called on the main thread for visual updates.
    if (!m_initialized) return;
}

void Kick::generateBlock(uint32_t frameCount) {
    if (!m_initialized) return;

    // Resize buffer if needed
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    float basePitch = static_cast<float>(pitch);
    float pitchEnvAmt = static_cast<float>(pitchEnv);
    float pitchDecayTime = static_cast<float>(pitchDecay) * m_sampleRate;
    float ampDecayTime = static_cast<float>(decay) * m_sampleRate;
    float clickAmt = static_cast<float>(click);
    float driveAmt = static_cast<float>(drive);
    float vol = static_cast<float>(volume);

    float pitchDecayRate = (pitchDecayTime > 0) ? (1.0f / pitchDecayTime) : 1.0f;
    float ampDecayRate = (ampDecayTime > 0) ? (1.0f / ampDecayTime) : 1.0f;
    float clickDecaySamples = m_sampleRate * 0.002f;  // 2ms = ~96 samples at 48kHz
    float clickDecayRate = 1.0f / clickDecaySamples;

    for (uint32_t i = 0; i < frameCount; ++i) {
        // Compute current frequency (pitch envelope)
        float freq = basePitch + pitchEnvAmt * m_pitchEnvValue;
        float phaseInc = freq / m_sampleRate;

        // Generate sine oscillator
        float osc = std::sin(m_phase * TWO_PI);

        // Generate click (short noise burst)
        float click = 0.0f;
        if (m_clickEnv > 0.0f && clickAmt > 0.0f) {
            // Simple noise for click
            uint32_t seed = static_cast<uint32_t>(m_phase * 1000000.0f) ^ 0x5DEECE66D;
            seed ^= seed << 13;
            seed ^= seed >> 17;
            seed ^= seed << 5;
            click = ((seed / 2147483648.0f) - 1.0f) * m_clickEnv * clickAmt;
        }

        // Mix and apply envelope
        float sample = (osc + click) * m_ampEnv;

        // Apply soft saturation/drive
        if (driveAmt > 0.0f) {
            sample = softClip(sample * (1.0f + driveAmt * 3.0f));
        }

        sample *= vol;

        // Output stereo
        m_output.samples[i * 2] = sample;
        m_output.samples[i * 2 + 1] = sample;

        // Advance phase
        m_phase += phaseInc;
        if (m_phase >= 1.0f) m_phase -= 1.0f;

        // Decay envelopes (exponential)
        m_pitchEnvValue *= (1.0f - pitchDecayRate);
        m_ampEnv *= (1.0f - ampDecayRate * 0.1f);  // Slower for smooth decay
        m_ampEnv = std::max(0.0f, m_ampEnv - ampDecayRate * 0.001f);
        m_clickEnv *= (1.0f - clickDecayRate);
    }
}

void Kick::handleEvent(const AudioEvent& event) {
    // Let base class handle Trigger -> onTrigger()
    AudioOperator::handleEvent(event);

    // Handle additional event types
    if (event.type == AudioEventType::Reset) {
        reset();
    }
}

void Kick::cleanup() {
    releaseOutput();
    m_initialized = false;
}

void Kick::onTrigger() {
    m_ampEnv = 1.0f;
    m_pitchEnvValue = 1.0f;
    m_clickEnv = 1.0f;
    // Don't reset phase for punch
}

void Kick::reset() {
    m_phase = 0.0f;
    m_ampEnv = 0.0f;
    m_pitchEnvValue = 0.0f;
    m_clickEnv = 0.0f;
}

float Kick::softClip(float x) const {
    // Tanh soft clipping
    if (x > 1.0f) return std::tanh(x);
    if (x < -1.0f) return std::tanh(x);
    return x;
}

bool Kick::drawVisualization(VizDrawList* dl, float minX, float minY, float maxX, float maxY) {
    VizHelpers viz(dl);
    VizBounds bounds{minX, minY, maxX - minX, maxY - minY};

    viz.drawBackground(bounds, VizColors::BackgroundDark);

    // Amplitude envelope bar
    VizBounds barBounds = bounds.inset(bounds.w * 0.2f, 4.0f);
    viz.drawEnvelopeBar(barBounds, m_ampEnv, VizColors::EnvelopeWarm);

    // Pitch indicator line
    if (m_pitchEnvValue > 0.01f) {
        float pitchY = bounds.y + 8 + (bounds.h - 16) * (1.0f - m_pitchEnvValue);
        dl->AddLine({barBounds.x - 4, pitchY}, {barBounds.right() + 4, pitchY},
                    VizColors::Active, 2.0f);
    }

    return true;
}

} // namespace vivid::audio
