#include <vivid/audio/kick.h>
#include <vivid/audio_graph.h>
#include <vivid/context.h>
#include <imgui.h>
#include <cmath>

namespace vivid::audio {

void Kick::init(Context& ctx) {
    m_sampleRate = AUDIO_SAMPLE_RATE;
    allocateOutput();
    reset();
    m_initialized = true;
}

void Kick::process(Context& ctx) {
    // In pull-based mode, audio is generated by generateBlock() on the audio thread.
    // process() is only called on the main thread for visual updates.
    if (!m_initialized) return;
}

void Kick::generateBlock(uint32_t frameCount) {
    if (!m_initialized) return;

    // Resize buffer if needed
    if (m_output.frameCount != frameCount) {
        m_output.resize(frameCount);
    }

    float basePitch = static_cast<float>(pitch);
    float pitchEnvAmt = static_cast<float>(pitchEnv);
    float pitchDecayTime = static_cast<float>(pitchDecay) * m_sampleRate;
    float ampDecayTime = static_cast<float>(decay) * m_sampleRate;
    float clickAmt = static_cast<float>(click);
    float driveAmt = static_cast<float>(drive);
    float vol = static_cast<float>(volume);

    float pitchDecayRate = (pitchDecayTime > 0) ? (1.0f / pitchDecayTime) : 1.0f;
    float ampDecayRate = (ampDecayTime > 0) ? (1.0f / ampDecayTime) : 1.0f;
    float clickDecaySamples = m_sampleRate * 0.002f;  // 2ms = ~96 samples at 48kHz
    float clickDecayRate = 1.0f / clickDecaySamples;

    for (uint32_t i = 0; i < frameCount; ++i) {
        // Compute current frequency (pitch envelope)
        float freq = basePitch + pitchEnvAmt * m_pitchEnvValue;
        float phaseInc = freq / m_sampleRate;

        // Generate sine oscillator
        float osc = std::sin(m_phase * TWO_PI);

        // Generate click (short noise burst)
        float click = 0.0f;
        if (m_clickEnv > 0.0f && clickAmt > 0.0f) {
            // Simple noise for click
            uint32_t seed = static_cast<uint32_t>(m_phase * 1000000.0f) ^ 0x5DEECE66D;
            seed ^= seed << 13;
            seed ^= seed >> 17;
            seed ^= seed << 5;
            click = ((seed / 2147483648.0f) - 1.0f) * m_clickEnv * clickAmt;
        }

        // Mix and apply envelope
        float sample = (osc + click) * m_ampEnv;

        // Apply soft saturation/drive
        if (driveAmt > 0.0f) {
            sample = softClip(sample * (1.0f + driveAmt * 3.0f));
        }

        sample *= vol;

        // Output stereo
        m_output.samples[i * 2] = sample;
        m_output.samples[i * 2 + 1] = sample;

        // Advance phase
        m_phase += phaseInc;
        if (m_phase >= 1.0f) m_phase -= 1.0f;

        // Decay envelopes (exponential)
        m_pitchEnvValue *= (1.0f - pitchDecayRate);
        m_ampEnv *= (1.0f - ampDecayRate * 0.1f);  // Slower for smooth decay
        m_ampEnv = std::max(0.0f, m_ampEnv - ampDecayRate * 0.001f);
        m_clickEnv *= (1.0f - clickDecayRate);
    }
}

void Kick::handleEvent(const AudioEvent& event) {
    // Let base class handle Trigger -> onTrigger()
    AudioOperator::handleEvent(event);

    // Handle additional event types
    if (event.type == AudioEventType::Reset) {
        reset();
    }
}

void Kick::cleanup() {
    releaseOutput();
    m_initialized = false;
}

void Kick::onTrigger() {
    m_ampEnv = 1.0f;
    m_pitchEnvValue = 1.0f;
    m_clickEnv = 1.0f;
    // Don't reset phase for punch
}

void Kick::reset() {
    m_phase = 0.0f;
    m_ampEnv = 0.0f;
    m_pitchEnvValue = 0.0f;
    m_clickEnv = 0.0f;
}

float Kick::softClip(float x) const {
    // Tanh soft clipping
    if (x > 1.0f) return std::tanh(x);
    if (x < -1.0f) return std::tanh(x);
    return x;
}

bool Kick::drawVisualization(ImDrawList* dl, float minX, float minY, float maxX, float maxY) {
    ImVec2 min(minX, minY);
    ImVec2 max(maxX, maxY);
    float width = maxX - minX;
    float height = maxY - minY;
    float cx = (minX + maxX) * 0.5f;

    // Dark background
    dl->AddRectFilled(min, max, IM_COL32(30, 25, 35, 255), 4.0f);

    // Get envelope values
    float ampEnv = m_ampEnv;
    float pitchEnv = m_pitchEnvValue;

    // Amplitude envelope bar (bottom up, warm orange)
    float barWidth = width * 0.6f;
    float barMaxH = height * 0.75f;
    float barH = barMaxH * ampEnv;
    ImU32 barColor = IM_COL32(255, 140, 50, 255);
    float barLeft = cx - barWidth * 0.5f;
    float barRight = cx + barWidth * 0.5f;
    dl->AddRectFilled(
        ImVec2(barLeft, maxY - 4 - barH),
        ImVec2(barRight, maxY - 4),
        barColor, 3.0f);

    // Pitch indicator (small dot or line that moves down as pitch decays)
    if (pitchEnv > 0.01f) {
        float pitchY = minY + 8 + (height - 16) * (1.0f - pitchEnv);
        ImU32 pitchColor = IM_COL32(100, 200, 255, 200);
        dl->AddLine(
            ImVec2(barLeft - 4, pitchY),
            ImVec2(barRight + 4, pitchY),
            pitchColor, 2.0f);
    }

    return true;
}

} // namespace vivid::audio
